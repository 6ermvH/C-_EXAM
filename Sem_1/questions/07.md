## Билет 9 Обзор стандартной библиотеки C

### `string.h (memcpy, memcmp, strcpy, strcmp, strcat, strstr, strchr, strtok)`

**`string.h`** - Библиотека, предназначенная для работы со строками и массивами.

### 1. **`memcpy`**

Копирует определенное количество байт из одной области памяти в другую.

**Сигнатура функции:**

```c
void *memcpy(void *dest, const void *src, size_t n);
```

**Принцип работы:**

- `dest` - указатель на место назначения
- `src` - указатель на источник
- `n` - количество байт для копирования

Функция возвращает указатель на `dest`

---

### 2. **`memcmp`**

Побайтово сравнивает два блока памяти

**Сигнатура функции:**

```c
int memcmp(const void *ptr1, const void *ptr2, size_t n);
```

**Принцип работы:**

- `ptr1` и `ptr2` - указатели на сравниваемые блоки памяти
- `n` - количество байт для сравнения
- Возвращает:
    - 0, если `ptr1` и `ptr2` равны;
    - положительное число, если первый отличающийся байт в `ptr1` больше, чем в`ptr2`;
    - отрицательное, если наоборот

---

### 3. **`strcpy`**

копирует строки включая завершающий нуль-символ

**Сигнатура функции:**

```c
char *strcpy(char *dest, const char *src);
```

**Принцип работы:**

- `dest` - указатель на строку назначения
- `src` - указатель на источник

**Важно!**

Строка в `dest` должна быть достаточной длины для копирования!

---

### 4. **`strcmp`**

Сравнивает две строки посимвольно

**Сигнатура функции:**

```c
int strcmp(const char *str1, const char *str2);
```

**Принцип работы:**

- `str1` и `str2` - указатели на сравниваемые строки
- Возвращает:
  - 0, если строки равны
  - положительное число, если `str1` больше `str2`
  - отрицательно число, если наоборот

---

### 5. **`strcat`**

Добавляет строку `src` в конец строки `dest`

**Сигнатура функции:**

```c
char *strcat(char *dest, const char *src);
```

**Принцип работы:**

- `dest` - указатель на строку назначения
- `src` - копируемая строка
- возвращает указатель на `dest`

**Важно!**

`dest` должна быть достаточной длины для копирования

---

### 6. **`strstr`**

находит первое вхождение строки `needle` в строке `haystack`

**Сигнатура функции:**

```c
char *strstr(const char *haystack, const char *needle);
```

**Принцип работы:**

- `haystack` - строка, в которой производится поиск
- `needle` - строка, которую ищем в `haystack`
- Возвращает указатель на начало найденной подстроки или `NULL`, если подстрока отсутствует

---

### 7. **`strchr`**

Находит первое вхождение символа в строке

**Сигнатура функции:**

```c
char *strchr(const char *str, int c);
```

**Принцип работы:**

- `str` - строка, в которой производится поиск
- `c` - символ, который мы ищем
- Возвращает указатель на первое вхождение символа или `NULL`, если символ отсутствует

---

### 8. **`strtok`**

Разделяет строку на части на основе разделителей

**Сигнатура функции:**

```c
char *strtok(char *str, const char *delim);
```

**Принцип работы:**

- `str` - строка, которую нужно разделить
- `delim` - строка, в которой содержится разделитель
- Возвращает указатель на токен или `NULL`, если токены закончились

**Пример:**

```c
char str[] = "Hello, world!";
char *token = strtok(str, ", ");
while (token != NULL) {
    printf("%s\n", token); // Выводит "Hello" и "world!"
    token = strtok(NULL, ", ");
}
```

>Не самая интуитивно понятная функция, для лучшего понимания можно глянут [Видос](https://www.youtube.com/watch?v=nrO_pXGZc3Y) с подробным обзором

### `stdlib.h (atoi, strtoll, srand/rand, qsort)`

**`stdlib.h`** - библиотека, предназначенная для работы с память, содержащая алгоритмы.

### 1. **`atoi`**

Преобразует строку в число `int`

**Сигнатура функции:**

```c
int atoi(const char *str);
```

**Принцип работы:**

- `str` - указатель на строку, которую нужно преобразовать
- Преобразует строку, пока допустимые для числа символы
- Если строка некорректна - `Undefined Behavior`
- Возвращает целое число `int`

---

### 2. **`strtoll`**

Преобразует строку в число `long long`

**Сигнатура функции:**

```c
long long strtoll(const char *str, char **endptr, int base);
```

**Принцип работы:**

- `str` - указатель на строку, которую нужно преобразовать
- `endptr` - указатель на указатель, который будет указывать на остаток строки после числа

>Звучит ужасно

- `base` - основание системы счисления
- Возвращает преобразованное число `long long`

**Пример:**

```c
int main() {
    char str[] = "12345abcd";
    char *end;
    long long num = strtoll(str, &end, 10);
    printf("%lld\n", num);  // Вывод: 12345
    printf("Остаток строки: %s\n", end); // Вывод: abcd
    return 0;
}
```

---

### 3. **`srand/rand`**

Используются для генерации псевдослучайных чисел

**Сигнатура функции:**

```c
void srand(unsigned int seed);
int rand(void);
```

**Принцип работы:**

- `srand(seed)` - устанавливает начальное значение для генерации случайных чисел
  - `seed` - само значение
- `rand()` - возвращает случайное значение в диапазоне от `0` до `RAND_MAX` (определен в `<stdlib.h>`)

>Для полного понимания этих функций можно глянуть [этот](https://www.youtube.com/watch?v=ewVeA0XzI8g) видос

---

### 4. **`qsort`**

Выполняет быструю сортировку на массиве произвольного типа (Quick Sort)

**Сигнатура функции:**

```c
void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void *));
```

**Принцип работы:**

- `base` - указатель на первый элемент массива
- `nitems` - количество элементов массива
- `size` - размер одного элемента
- `compar` - указатель на функцию сравнения, которая возвращает:
  - Отрицательное значение, если первый элемент меньше второго
  - Ноль, если они равны
  - Положительное значение, если первый элемент больше второго.

**Пример компаратора для `int`**

```c
int compare(const void *a, const void *b) {
    return (*(int *)a - *(int *)b); // Сравнение двух элементов
}
```

**Пример использования функции:**

```c
int main() {
    int arr[] = {5, 2, 9, 1, 5, 6};
    size_t n = sizeof(arr) / sizeof(arr[0]);

    qsort(arr, n, sizeof(int), compare);

    for (size_t i = 0; i < n; i++) {
        printf("%d ", arr[i]); // Вывод: 1 2 5 5 6 9
    }
    return 0;
}
```
